{"meta":{"title":"用唇语说colorful的博客","subtitle":null,"description":null,"author":"黄智鹏","url":"http://Savingss.github.io"},"pages":[{"title":"tags","date":"2017-09-13T08:57:24.000Z","updated":"2017-09-13T09:01:00.054Z","comments":false,"path":"tags/index.html","permalink":"http://Savingss.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-09-13T09:01:23.000Z","updated":"2017-09-13T09:01:32.073Z","comments":false,"path":"categories/index.html","permalink":"http://Savingss.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"数组去重（原生和ES6的写法）","slug":"数组去重（原生和ES6的写法）","date":"2017-10-30T02:43:04.652Z","updated":"2017-10-30T02:44:52.516Z","comments":true,"path":"2017/10/30/数组去重（原生和ES6的写法）/","link":"","permalink":"http://Savingss.github.io/2017/10/30/数组去重（原生和ES6的写法）/","excerpt":"","text":"要求：用JavaScript脚本为Array对象添加一个数组去重的方法12345678910var a = [1, 1, 2, 2, 3, 3, 0, 0];// 1、利用indexof（不兼容IE8及以下）是es5新出的只能适用于IE9及其他标准浏览器Array.prototype.unique1 = function () &#123; let arr = []; this.forEach((val, ind) =&gt; &#123; arr.indexOf(val) &lt; 0 ? arr.push(val) : null; &#125;) return arr;&#125;console.log(a.unique1()); 123456789101112131415// 2、利用对象遍历的方法 for in 关键是key唯一。缺点：往对象里面添加键值对的时候，键会隐式调用toString。Array.prototype.unique2 = function () &#123; var obj = &#123;&#125;; var arr = []; this.forEach((val, ind) =&gt; &#123; var cur = this[ind]; obj[cur] = cur; &#125;) // console.log(obj); for (var key in obj) &#123; arr.push(obj[key]) &#125; return arr;&#125;console.log(a.unique2()); 123456789101112131415//3、利用对象方法：把当前项值当成对象的属性和属性名Array.prototype.unique3 = function () &#123; var obj = &#123;&#125;; // console.log(this); for (var i = 0; i &lt; this.length; i++) &#123; var cur = this[i]; if (obj[cur] === cur) &#123; this.splice(i, 1); i--; &#125; obj[cur] = cur; &#125; return this;&#125;console.log(a.unique3()); ES6的方法： 12345// 1、利用Array.from()方法可以将Set结构转为数组Array.prototype.unique4 = function () &#123; return Array.from(new Set(this))&#125;console.log(a.unique4()); 12345//2、利用扩展运算符(...)提供了一种更便捷的去重方法Array.prototype.unique5 = function () &#123; return [...new Set(this)]&#125;console.log(a.unique5());","categories":[],"tags":[]},{"title":"简要了解前端框架中飞MVC、MVP、MVVM是什么","slug":"简要了解前端框架中飞MVC、MVP、MVVM是什么","date":"2017-09-18T08:04:52.381Z","updated":"2017-09-19T08:28:39.201Z","comments":true,"path":"2017/09/18/简要了解前端框架中飞MVC、MVP、MVVM是什么/","link":"","permalink":"http://Savingss.github.io/2017/09/18/简要了解前端框架中飞MVC、MVP、MVVM是什么/","excerpt":"","text":"MVC 这个图的意思是这样的：View传送指令到Controller，而Controller则负责完成业务逻辑，然后再要求Model改变状态，最后Model则将新的数据发送到View，使用户界面得到改变。 MVP MVP和MVC的区别最明显的首先是Controller改名为Present，而且各部分之间的通信都是双向的。同时View和Model不发生联系，是通过Present传递的。 MVVM 这种模式，最明显的特点是双向绑定，方便了前端开发人员和后端开发人员的有效分工。View是指页面和用户交互的部分，ViewModel是一个用于数据转换的Controller，它可以把Model中的信息转化成View，同时可以从View中把命令传给Model。","categories":[],"tags":[]},{"title":"JS的几种排序算法","slug":"JS算法","date":"2017-09-15T06:46:21.168Z","updated":"2017-09-19T08:36:27.169Z","comments":true,"path":"2017/09/15/JS算法/","link":"","permalink":"http://Savingss.github.io/2017/09/15/JS算法/","excerpt":"","text":"var ary = [12,2,36,80,99,56,68],ary2 = [1,2,3,4,5,6,7],n = 0; 快速查询： function quickSort(ary){ if (ary&lt;=1) { return ary; } var mid_ind = Math.floor(ary.length/2); var mid = ary.splice(mid_ind,1); var left = [],right = []; for (var i = 0; i &lt; ary.length; i++) { var cur = ary[i]; if (cur&lt;mid[0]) { left.push(cur) }else { right.push(cur) } } return quickSort(left).concat(mid,quickSort(right)); } var newArry = quickSort(ary); 冒泡排序： function bubble(ary){ var flag = true; 优化代码部分：添加一个flag判断如果一开始数组就已经是排好序的话，减少循环次数，提升性能。 for (var j = 0; j &lt; ary.length-1; j++) { for (var i = 0; i &lt; ary.length-1-j; i++) { n++; 测试循环次数，一开始在全局下定义n的值为0，方法执行之后输出n的次数即可完成测试 if (ary[i]&gt;ary[i+1]) { var temp = ary[i]; ary[i] = ary[i+1]; ary[i+1] = temp; flag = false; } } 优化代码部分：添加一个flag判断如果一开始数组就已经是排好序的话，减少循环次数，提升性能。 if (flag) { return ary; } } return ary; } console.log(bubble(ary2)); console.log(n); 插入排序法： function insertSort(ary){ var newArry = []; newArry[0] = ary[0]; 将原数组中的每一项依次和新数组中的值进行比较,如果比他小,就放到该项的前面 for (var i = 0; i &lt; ary.length; i++) { 依次和新数组进行对比 for (var j = 0; j &lt; newArry.length; j++) { if (ary[i]&lt;newArry[j]) { newArry.splice(j,0,ary[i]); break; }else { 如果j等于新数组的长度-1的话，说明已经和前面都比完，并且是最大的 if (j===newArry.length-1) { newArry.push(ary[i]); break; } } } } return newArry; } console.log(insertSort(ary)); 利用递归计算1到100的和,递归就是函数自己调用自己，损耗性能。 function sum(n){ if (n&lt;=1) { return n; } return n+sum(n-1); } console.log(sum(100));","categories":[],"tags":[]},{"title":"JS常用正则","slug":"JS常用正则","date":"2017-09-14T16:48:40.295Z","updated":"2017-09-19T08:54:29.253Z","comments":true,"path":"2017/09/15/JS常用正则/","link":"","permalink":"http://Savingss.github.io/2017/09/15/JS常用正则/","excerpt":"","text":"用户名 1234//用户名正则，4到16位（字母，数字，下划线，减号）var uPattern = /^[a-zA-Z0-9_-]&#123;4,16&#125;$/;//输出 trueconsole.log(uPattern.test(&quot;iFat3&quot;)); 密码强度正则 123456//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符var pPattern = /^.*(?=.&#123;6,&#125;)(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/;//输出 trueconsole.log(&quot;==&quot;+pPattern.test(&quot;iFat3#&quot;));// 必须由数字和字母组成的至少6位密码var regpwd = /^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]&#123;6,21&#125;$/; Email 1234//Email正则var ePattern = /^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]&#123;2,4&#125;)$/;//输出 trueconsole.log(ePattern.test(&lt;a href=&quot;mailto:65974040@qq.com&quot;&gt;65974040@qq.com&lt;/a&gt;)); 手机号正则 1234//手机号正则var mPattern = /^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\\d&#123;8&#125;$/;//输出 trueconsole.log(mPattern.test(&quot;18600000000&quot;)); 身份证 1234//身份证号（18位）正则var cP = /^[1-9]\\d&#123;5&#125;(18|19|([23]\\d))\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;[0-9Xx]$/;//输出 trueconsole.log(cP.test(&quot;11010519880605371X&quot;)); 日期正则 1234567891011121314//日期正则，简单判定,未做月份及日期的判定var dP1 = /^\\d&#123;4&#125;(\\-)\\d&#123;1,2&#125;\\1\\d&#123;1,2&#125;$/;//输出 trueconsole.log(dP1.test(&quot;2017-05-11&quot;));//输出 trueconsole.log(dP1.test(&quot;2017-15-11&quot;));//日期正则，复杂判定var dP2 = /^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/;//输出 trueconsole.log(dP2.test(&quot;2017-02-11&quot;));//输出 falseconsole.log(dP2.test(&quot;2017-15-11&quot;));//输出 falseconsole.log(dP2.test(&quot;2017-02-29&quot;)); 扣扣号码 1234//QQ号正则，5至11位var qqPattern = /^[1-9][0-9]&#123;4,10&#125;$/;//输出 trueconsole.log(qqPattern.test(&quot;65974040&quot;)); 包含中文正则 1234//包含中文正则var cnPattern = /[\\u4E00-\\u9FA5]/;//输出 trueconsole.log(cnPattern.test(&quot;42度&quot;));","categories":[],"tags":[]},{"title":"ES6（ECMAScript 6）基础","slug":"ES6基础笔记","date":"2017-09-13T12:07:04.761Z","updated":"2017-09-19T08:56:20.035Z","comments":true,"path":"2017/09/13/ES6基础笔记/","link":"","permalink":"http://Savingss.github.io/2017/09/13/ES6基础笔记/","excerpt":"","text":"在es6中是用let声明变量的 跟var类似 跟var的区别在于let只在它的代码块中有效一个大括号 就是一个代码块==&gt;作用域 在es5中 代码块中声明的变量在任何地方都能取到let 的应用场景一般是用在for循环中比较有用 不能变量提升使用let 注意事项 1.不能重复声明使用const 声明变量 只能声明常量 一旦声明 不能改变，只在代码块中有效。例如： 12const PI = 3.141569；const PI = 3.14;//此时会报错为：它不是一个常量 let的经典面试题：12345678910一个for循环，用var声明一个变量，然后要我输入几就打印几var arr = [];for (var i = 0; i &lt; 10; i++) &#123; arr[i] = function () &#123; console.log(i); &#125;&#125;arr[6](); //此时输出10应该把for循环里面的var改为let，让let解决变量提升，不能让它变量提升，利用let的特性就是它只在它的代码块有效 12const PI = 3.1415982; PI = 3.14;//报错：Uncaught TypeError: Assignment to constant variable.说明PI不是一个常量 const声明的变量 只在代码块会中有效 { const a = 123; } console.log(a);//a is not define var arr = Array.prototype.slice.call(arguments) 变量的解构赋值es6中允许按照一定的模式,将数组和对象中的值,对变量进行赋值,这被称为解构。1234完全解构：var [a,b,c] = [1,2,3];不完全解构：var [a,,c] = [1,2,3]; 12对象的赋值var &#123;x1,x2,y1&#125; = &#123;x1:1,y1:2,x2:3&#125; 12数组跟对象结合var [&#123;x1,y1,z1&#125;,[x2,y2,z2],x3,z3] = [&#123;z5:10,y1:20&#125;,[30,40],50] 1234567891011121314对象扩展运算符 使用三个点var [head,...detail] = [1,2,23];detail打印出来的是[2,23]；arguments对象不是一个 Array 。它类似于数组，但除了 长度之外没有任何数组属性。例如，它没有 pop 方法。但是它可以被转换为一个真正的数组es6中有两种方法可以把arguments转化为数组spread扩展符就是三个点...例如：function show(...argments)&#123; console.log(arguments);&#125;function show(...argments)&#123; var arr = Array.from(arguments); console.log(arr);&#125;show(&apos;啊锐&apos;,&apos;阿荣&apos;,&apos;振诚&apos;,&apos;庆秋&apos;) 字符串模板 1234567891011121314151617181920var a = 1;var b = 2;es5写法：// var str = &quot;asfdasdasd&quot;+a+&quot;dasdasdasd&quot;+b;// console.log(str);// 模板字符串 是esc下面那个键var str1 = `asfdasdas$&#123;a&#125;dadasdasdasd$&#123;b&#125;b`console.log(str1);应用场景（小demo）：动态添加 var imgSrc = &apos;./1.png&apos;; var title = &apos;我是一个h2&apos;; $(&apos;ul&apos;).append(` &lt;li&gt; &lt;h2&gt;$&#123;title&#125;&lt;/h2&gt; &lt;img src=$&#123;imgSrc&#125; alt=&quot;&quot;&gt; &lt;/li&gt; `) 12345678910111213141516数组赋值Es5：var arr1 = [1,2,3,4];var arr2 = [];for(var i = 0;i &lt;arr1.length;i++)&#123; arr2.push(arr1[i]);&#125;console.log(arr2);Es6：var arr1 = [1,2,3,4];var newarr = Array.from(arr1);console.log(newarr);也可以使用扩展运算符,三个点...var arr1 = [1,2,3];var newarr = [...arr1];console.log(newarr); 注意：两个数组之间不能直接比较无论是“==”或者“===”都会返回false。因为JavaScript里面Array是对象，==或===操作符只能比较两个对象是否是同一个实例，也就是是否是同一个对象引用。目前JavaScript没有内置的操作符判断对象的内容是否相同。只能通过遍历数组元素比较。 map和for-of 12345678910111213141516171819202122232425262728293031map 在 es6中能去遍历数组和对象的对象 ,叫map对象第一步 创建map对象var person = &#123; name:&apos;黄智鹏&apos;, age:18, fav:function()&#123; console.log(&apos;英语&apos;) &#125; &#125;var map = new Map();console.log(map);设置map对象 使用set方法var ar =[10,20];map的key值可以是对象也可以是字符串，数组；JavaScript的对象（Objetct），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当做键。这就给他的使用带来了很大的限制、。为了解决这个问题ES6提供了Map数据结构它类似与对象，也是键值对集合，但是&apos;键&apos;的范围不限于字符串，各种类型的值（包括对象）都可以当做键。也就是说，Object结构提供了字符“串——值”的对应，Map结构提供了“值-值”的对应，是一种更完善的Hash结构实现。如果你需要键值对的结构，Map比Object更合适。map.set(person,1);map.set(&apos;b&apos;,2);map.set(&apos;c&apos;,3);var a = map.get(&apos;a&apos;)console.log(a);has()返回一个布尔值 如果有 则返回trueconsole.log(map.has(&apos;c&apos;));删除map.delete(&apos;a&apos;);要想去遍历或者说使用了这个map对象，一定要注意要用for of不要用for in 箭头函数 es6的箭头函数 123456789101112131415161718192021222324252627282930313233343536伪代码 function add(x)&#123;&#125; ======&gt; var add = (x)=&gt;&#123;&#125; add()var add = (x) =&gt; &#123; return x&#125;ps:ES6的简写也能出现效果如下，注意的是有return的时候可以这么写var add = x=&gt;x;alert(add(40));应用小demo：box.click = ()=&gt;&#123;alert(&apos;123&apos;)&#125;;注意: 使用箭头函数 要注意两个点1. 会改变this的指向 它指向了window对象; var name = &apos;张琳&apos;; var person = &#123; name: &apos;焦🐑&apos;, age: 2, fav: () =&gt; &#123; // 使用箭头函数 会改变this的指向 它指向了window对象 console.log(this); console.log(`$&#123;this.name&#125;喜欢打王者荣耀`); &#125; &#125; person.fav();//this.name指向window下的name，会打印出张琳喜欢打王者荣耀2. 使用箭头函数 arguments就不能使用var person2 = &#123; name: &apos;焦🐑&apos;, age: 2, fav: () =&gt; &#123; 使用箭头函数 arguments就不能使用 console.log(arguments);//报错arguments is not defined console.log(`$&#123;this.name&#125;喜欢打王者荣耀`); &#125; &#125; person2.fav(1,2,3,4); ES6中对象的写法，使用箭头函数要想打印对象里的属性值 是不可行的，那么我们可以使用对象的单体模式模式 123456789fav()&#123;&#125;对象的单体模式写法 ===等同于ES5写法===&gt; fav:function()&#123;&#125;var person = &#123; name:&apos;kk仔&apos;, age:20, fav()&#123; alert(this.name); &#125;&#125;person.fav(); 面向对象的三个特性 : 封装 继承(所谓继承,即继承父类的属性和方法,同样它还可以拥有自己的属性和方法) 多态 123456789101112131415161718192021222324252627282930313233343536373839es5中 构造函数 创建对象的写法function Person(name,age)&#123; this.name = name; this.age = age;&#125;Person.prototype.showName = function()&#123; console.log(this.name);&#125;Person.prototype.showAge = function()&#123; console.log(this.age);&#125;var p = new Person(&apos;焦🐑&apos;,18);p.showName();ps：比如说，上面这个构造函数Person，在下面new了这个Person之后我们可以称为这个Person对象就是一个类，所谓一个类呢，就是一个对象。而ES6中构造函数 创建对象的写法 是这样写的在大括号里面可以定义它自己想要的属性和方法，要想定义属性必须使用constructor方法class Person&#123; //在new了一个Person之后，constructor方法会自动调用（自己调用自己一次）就创建了一个实例，说白了就是一个对象 constructor（name,age）&#123; this.name = name; this.age = age; &#125; //如果要写方法的话必须要使用对象的单体模式写比如说： showName()&#123; console.log(this.name); &#125; showAge()&#123; console.log(this.age); &#125;&#125;new p1 = new Person(&apos;朱博宇&apos;,16);验证：console.log(p1.constructor === Person)//返回trueprototype 对应的对象中， 有一个天生自带的属性叫做constructor, （构造函数），这个属性的属性值指向的是当前函数本身。 承接上面的例子，面向对象的继承 1234567891011121314151617class student extends Person&#123; //继承 既继承属性 又继承方法 并且也有属于自己的属性和方法 constructor(name,age,fav)&#123; //子类一旦用到了继承 constructor和super()同时存在的 //super方法是为了继承父类的属性 super(name,age); this.fav = fav; &#125; showFav()&#123; console.log(&apos;前端&apos;); &#125;&#125;var p = new Person(&apos;张三&apos;,19);p.showFav();//报错：p.showFav() is not a function父级不能调用子级的方法，子级可以调用父级的方法，为啥，因为继承嘛！~var s = Student(&apos;李斯&apos;,20);s.showName();//证明s继承了父级的方法","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-09-12T06:24:46.150Z","updated":"2017-09-12T06:24:46.151Z","comments":true,"path":"2017/09/12/hello-world/","link":"","permalink":"http://Savingss.github.io/2017/09/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}