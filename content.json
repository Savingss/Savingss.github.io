{"meta":{"title":"用唇语说colorful的博客","subtitle":null,"description":null,"author":"黄智鹏","url":"http://Savingss.github.io"},"pages":[{"title":"tags","date":"2017-09-13T08:57:24.000Z","updated":"2017-09-13T09:01:00.054Z","comments":false,"path":"tags/index.html","permalink":"http://Savingss.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-09-13T09:01:23.000Z","updated":"2017-09-13T09:01:32.073Z","comments":false,"path":"categories/index.html","permalink":"http://Savingss.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"ES6（ECMAScript 6）基础","slug":"ES6基础笔记","date":"2017-09-13T12:07:04.761Z","updated":"2017-09-13T12:12:00.906Z","comments":true,"path":"2017/09/13/ES6基础笔记/","link":"","permalink":"http://Savingss.github.io/2017/09/13/ES6基础笔记/","excerpt":"","text":"在es6中是用let声明变量的 跟var类似 跟var的区别在于let只在它的代码块中有效一个大括号 就是一个代码块==&gt;作用域 在es5中 代码块中声明的变量在任何地方都能取到let 的应用场景一般是用在for循环中比较有用 不能变量提升使用let 注意事项 1.不能重复声明使用const 声明变量 只能声明常量 一旦声明 不能改变，只在代码块中有效。例如： 12const PI = 3.141569；const PI = 3.14;//此时会报错为：它不是一个常量 let的经典面试题：12345678910一个for循环，用var声明一个变量，然后要我输入几就打印几var arr = [];for (var i = 0; i &lt; 10; i++) &#123; arr[i] = function () &#123; console.log(i); &#125;&#125;arr[6](); //此时输出10应该把for循环里面的var改为let，让let解决变量提升，不能让它变量提升，利用let的特性就是它只在它的代码块有效 12const PI = 3.1415982; PI = 3.14;//报错：Uncaught TypeError: Assignment to constant variable.说明PI不是一个常量 const声明的变量 只在代码块会中有效 { const a = 123; } console.log(a);//a is not define var arr = Array.prototype.slice.call(arguments) 变量的解构赋值es6中允许按照一定的模式,将数组和对象中的值,对变量进行赋值,这被称为解构。1234完全解构：var [a,b,c] = [1,2,3];不完全解构：var [a,,c] = [1,2,3]; 12对象的赋值var &#123;x1,x2,y1&#125; = &#123;x1:1,y1:2,x2:3&#125; 12数组跟对象结合var [&#123;x1,y1,z1&#125;,[x2,y2,z2],x3,z3] = [&#123;z5:10,y1:20&#125;,[30,40],50] 1234567891011121314对象扩展运算符 使用三个点var [head,...detail] = [1,2,23];detail打印出来的是[2,23]；arguments对象不是一个 Array 。它类似于数组，但除了 长度之外没有任何数组属性。例如，它没有 pop 方法。但是它可以被转换为一个真正的数组es6中有两种方法可以把arguments转化为数组spread扩展符就是三个点...例如：function show(...argments)&#123; console.log(arguments);&#125;function show(...argments)&#123; var arr = Array.from(arguments); console.log(arr);&#125;show(&apos;啊锐&apos;,&apos;阿荣&apos;,&apos;振诚&apos;,&apos;庆秋&apos;) 字符串模板 1234567891011121314151617181920var a = 1;var b = 2;es5写法：// var str = &quot;asfdasdasd&quot;+a+&quot;dasdasdasd&quot;+b;// console.log(str);// 模板字符串 是esc下面那个键var str1 = `asfdasdas$&#123;a&#125;dadasdasdasd$&#123;b&#125;b`console.log(str1);应用场景（小demo）：动态添加 var imgSrc = &apos;./1.png&apos;; var title = &apos;我是一个h2&apos;; $(&apos;ul&apos;).append(` &lt;li&gt; &lt;h2&gt;$&#123;title&#125;&lt;/h2&gt; &lt;img src=$&#123;imgSrc&#125; alt=&quot;&quot;&gt; &lt;/li&gt; `) 12345678910111213141516数组赋值Es5：var arr1 = [1,2,3,4];var arr2 = [];for(var i = 0;i &lt;arr1.length;i++)&#123; arr2.push(arr1[i]);&#125;console.log(arr2);Es6：var arr1 = [1,2,3,4];var newarr = Array.from(arr1);console.log(newarr);也可以使用扩展运算符,三个点...var arr1 = [1,2,3];var newarr = [...arr1];console.log(newarr); 注意：两个数组之间不能直接比较无论是“==”或者“===”都会返回false。因为JavaScript里面Array是对象，==或===操作符只能比较两个对象是否是同一个实例，也就是是否是同一个对象引用。目前JavaScript没有内置的操作符判断对象的内容是否相同。只能通过遍历数组元素比较。 map和for-of 12345678910111213141516171819202122232425262728293031map 在 es6中能去遍历数组和对象的对象 ,叫map对象第一步 创建map对象var person = &#123; name:&apos;黄智鹏&apos;, age:18, fav:function()&#123; console.log(&apos;英语&apos;) &#125; &#125;var map = new Map();console.log(map);设置map对象 使用set方法var ar =[10,20];map的key值可以是对象也可以是字符串，数组；JavaScript的对象（Objetct），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当做键。这就给他的使用带来了很大的限制、。为了解决这个问题ES6提供了Map数据结构它类似与对象，也是键值对集合，但是&apos;键&apos;的范围不限于字符串，各种类型的值（包括对象）都可以当做键。也就是说，Object结构提供了字符“串——值”的对应，Map结构提供了“值-值”的对应，是一种更完善的Hash结构实现。如果你需要键值对的结构，Map比Object更合适。map.set(person,1);map.set(&apos;b&apos;,2);map.set(&apos;c&apos;,3);var a = map.get(&apos;a&apos;)console.log(a);has()返回一个布尔值 如果有 则返回trueconsole.log(map.has(&apos;c&apos;));删除map.delete(&apos;a&apos;);要想去遍历或者说使用了这个map对象，一定要注意要用for of不要用for in 箭头函数 es6的箭头函数 123456789101112131415161718192021222324252627282930313233343536伪代码 function add(x)&#123;&#125; ======&gt; var add = (x)=&gt;&#123;&#125; add()var add = (x) =&gt; &#123; return x&#125;ps:ES6的简写也能出现效果如下，注意的是有return的时候可以这么写var add = x=&gt;x;alert(add(40));应用小demo：box.click = ()=&gt;&#123;alert(&apos;123&apos;)&#125;;注意: 使用箭头函数 要注意两个点1. 会改变this的指向 它指向了window对象; var name = &apos;张琳&apos;; var person = &#123; name: &apos;焦🐑&apos;, age: 2, fav: () =&gt; &#123; // 使用箭头函数 会改变this的指向 它指向了window对象 console.log(this); console.log(`$&#123;this.name&#125;喜欢打王者荣耀`); &#125; &#125; person.fav();//this.name指向window下的name，会打印出张琳喜欢打王者荣耀2. 使用箭头函数 arguments就不能使用var person2 = &#123; name: &apos;焦🐑&apos;, age: 2, fav: () =&gt; &#123; 使用箭头函数 arguments就不能使用 console.log(arguments);//报错arguments is not defined console.log(`$&#123;this.name&#125;喜欢打王者荣耀`); &#125; &#125; person2.fav(1,2,3,4); ES6中对象的写法，使用箭头函数要想打印对象里的属性值 是不可行的，那么我们可以使用对象的单体模式模式 123456789fav()&#123;&#125;对象的单体模式写法 ===等同于ES5写法===&gt; fav:function()&#123;&#125;var person = &#123; name:&apos;kk仔&apos;, age:20, fav()&#123; alert(this.name); &#125;&#125;person.fav(); 面向对象的三个特性 : 封装 继承(所谓继承,即继承父类的属性和方法,同样它还可以拥有自己的属性和方法) 多态 123456789101112131415161718192021222324252627282930313233343536373839es5中 构造函数 创建对象的写法function Person(name,age)&#123; this.name = name; this.age = age;&#125;Person.prototype.showName = function()&#123; console.log(this.name);&#125;Person.prototype.showAge = function()&#123; console.log(this.age);&#125;var p = new Person(&apos;焦🐑&apos;,18);p.showName();ps：比如说，上面这个构造函数Person，在下面new了这个Person之后我们可以称为这个Person对象就是一个类，所谓一个类呢，就是一个对象。而ES6中构造函数 创建对象的写法 是这样写的在大括号里面可以定义它自己想要的属性和方法，要想定义属性必须使用constructor方法class Person&#123; //在new了一个Person之后，constructor方法会自动调用（自己调用自己一次）就创建了一个实例，说白了就是一个对象 constructor（name,age）&#123; this.name = name; this.age = age; &#125; //如果要写方法的话必须要使用对象的单体模式写比如说： showName()&#123; console.log(this.name); &#125; showAge()&#123; console.log(this.age); &#125;&#125;new p1 = new Person(&apos;朱博宇&apos;,16);验证：console.log(p1.constructor === Person)//返回trueprototype 对应的对象中， 有一个天生自带的属性叫做constructor, （构造函数），这个属性的属性值指向的是当前函数本身。 承接上面的例子，面向对象的继承 1234567891011121314151617class student extends Person&#123; //继承 既继承属性 又继承方法 并且也有属于自己的属性和方法 constructor(name,age,fav)&#123; //子类一旦用到了继承 constructor和super()同时存在的 //super方法是为了继承父类的属性 super(name,age); this.fav = fav; &#125; showFav()&#123; console.log(&apos;前端&apos;); &#125;&#125;var p = new Person(&apos;张三&apos;,19);p.showFav();//报错：p.showFav() is not a function父级不能调用子级的方法，子级可以调用父级的方法，为啥，因为继承嘛！~var s = Student(&apos;李斯&apos;,20);s.showName();//证明s继承了父级的方法","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-09-12T06:24:46.150Z","updated":"2017-09-12T06:24:46.151Z","comments":true,"path":"2017/09/12/hello-world/","link":"","permalink":"http://Savingss.github.io/2017/09/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}